import * as React from "react"
import { PropertyControls, ControlType } from "framer"

enum SourceType {
    File = "File",
    URL = "URL",
}

type Props = {
    sourceType: SourceType
    file: string
    url: string
    shouldPlay: boolean
    debug: boolean
    loop: boolean
    muted: boolean
    effects: boolean
    cornerRadius: number
    shadow: boolean
    shadowRadius: number
    shadowOffset: number
    shadowColor: string
    greyscale: number
    saturation: number
    hue: number
    brightness: number
    contrast: number
    onEnded: () => void
    onError: () => void
    onPlaying: () => void
    onPause: () => void
    onPlay: () => void
    onStalled: () => void
    onCanPlay: () => void
    onCanPlayThrough: () => void
    onLoadedMetadata: () => void
    onDurationChanged: (duration: number) => void
    onProgress: (progress: number) => void
    onTimeUpdate: (currentTime: number, duration: number) => void
}

export class VideoPlayer extends React.Component<Props> {
    // Define some standard CSS for your component
    style: React.CSSProperties = {
        height: "100%",
        overflow: "hidden",
    }

    videoRef = React.createRef()

    videoState = {
        canPlay: false,
        canPlayThrough: false,
    }

    render() {
        var style = {
            ...this.style,
            borderRadius: `${this.props.cornerRadius}px`,
            boxShadow:
                this.props.shadow == true
                    ? `0px ${this.props.shadowOffset}px ${this.props.shadowRadius}px ${this.props.shadowColor}`
                    : "",
        }
        var url =
            this.props.sourceType == SourceType.URL
                ? this.props.url
                : this.props.file

        var effectOptions = []
        if (this.props.greyscale > 0) {
            effectOptions.push("grayscale(" + this.props.greyscale + "%)")
        }
        if (this.props.saturation != 100) {
            effectOptions.push("saturate(" + this.props.saturation + "%)")
        }
        if (this.props.hue > 0) {
            effectOptions.push("hue-rotate(" + this.props.hue + "deg)")
        }
        if (this.props.brightness != 100) {
            effectOptions.push("brightness(" + this.props.brightness + "%)")
        }
        if (this.props.contrast != 100) {
            effectOptions.push("contrast(" + this.props.contrast + "%)")
        }

        var videoStyle: React.CSSProperties = {
            objectFit: "cover",
            overflow: "hidden",
            backgroundColor: "black",
            borderRadius: `${this.props.cornerRadius}px`,
            filter: effectOptions.join(" "),
        }

        this.debug("render")
        return (
            <div style={style}>
                <video
                    style={videoStyle}
                    width="100%"
                    height="100%"
                    loop={this.props.loop}
                    ref={this.videoRef}
                    muted={this.props.muted}
                    src={url}
                />
            </div>
        )
    }

    debug(message: string, args: string[] = null) {
        if (!this.props.debug) {
            return
        }
        if (args) {
            console.log("VideoPlayer " + message, args)
        } else {
            console.log("VideoPlayer " + message)
        }
    }

    videoPlayer(): HTMLVideoElement {
        return this.videoRef.current as HTMLVideoElement
    }

    componentDidMount() {
        // Setup events
        this.videoPlayer().onended = this.onEnded.bind(this)
        this.videoPlayer().ondurationchange = this.onDurationChanged.bind(this)
        this.videoPlayer().onloadedmetadata = this.onLoadedMetadata.bind(this)
        this.videoPlayer().onloadeddata = this.onLoadedData.bind(this)
        this.videoPlayer().ontimeupdate = this.onTimeUpdate.bind(this)
        this.videoPlayer().oncanplay = this.onCanPlay.bind(this)
        this.videoPlayer().oncanplaythrough = this.onCanPlayThrough.bind(this)
        this.videoPlayer().onstalled = this.onStalled.bind(this)
        this.videoPlayer().onerror = this.onError.bind(this)
        this.videoPlayer().onplay = this.onPlay.bind(this)
        this.videoPlayer().onpause = this.onPause.bind(this)
        this.videoPlayer().onplaying = this.onPlaying.bind(this)
        this.checkPlayState()
    }

    checkPlayState() {
        let player = this.videoPlayer()
        if (player == null) {
            this.debug("VideoPlayer null?")
            return
        }
        this.debug("shouldPlay", [this.props.shouldPlay ? "true" : "false"])
        if (this.props.shouldPlay) {
            player.play()
            this.debug(" * play")
        } else {
            player.pause()
            this.debug(" * pause")
        }
    }

    shouldComponentUpdate(oldProps) {
        let props = [
            "url",
            "shouldPlay",
            "sourceType",
            "file",
            "url",
            "debug",
            "loop",
            "cornerRadius",
            "shadow",
            "shadowRadius",
            "shadowOffset",
            "shadowColor",
            "greyscale",
            "saturation",
            "hue",
            "brightness",
            "contrast",
        ]

        var changed = false

        props.forEach(prop => {
            if (oldProps[prop] !== this.props[prop]) {
                this.debug("updated", [
                    prop,
                    oldProps[prop] as string,
                    this.props[prop] as string,
                ])
                changed = true
            }
        })
        this.debug("shouldComponentUpdate", [changed ? "true" : "false"])
        return changed
    }

    componentDidUpdate(oldProps) {
        this.debug("componentDidUpdate")

        if (oldProps.shouldPlay != this.props.shouldPlay) {
            this.debug("componentDidUpdate shouldPlayChanged")
            this.checkPlayState()
        }
    }

    onPlay() {
        this.debug("onPlay")
        if (this.props.onPlay) {
            this.props.onPlay()
        }
    }

    onPause() {
        this.debug("onPause")
        if (this.props.onPause) {
            this.props.onPause()
        }
    }

    onPlaying() {
        this.debug("onPlaying")
        if (this.props.onPlaying) {
            this.props.onPlaying()
        }
    }

    onError(error) {
        this.debug("onError", error)
        if (this.props.onError) {
            this.props.onError()
        }
    }

    onStalled() {
        this.debug("onStalled")
        if (this.props.onStalled) {
            this.props.onStalled()
        }
    }

    onCanPlay() {
        this.debug("onCanPlay")
        this.videoState.canPlay = true
        if (this.props.onCanPlay) {
            this.props.onCanPlay()
        }
    }

    onCanPlayThrough() {
        this.debug("onCanPlayThrough")
        this.videoState.canPlayThrough = true
        if (this.props.onCanPlayThrough) {
            this.props.onCanPlayThrough()
        }
    }

    onLoadedData() {
        this.debug("onLoadedData")
        this.onTimeUpdate()
    }

    onLoadedMetadata() {
        this.debug("onLoadMetadata")
        this.onTimeUpdate()
        if (this.props.onLoadedMetadata) {
            this.props.onLoadedMetadata()
        }
    }

    onDurationChanged() {
        this.debug("onDurationChanged")
        this.onTimeUpdate()
        if (this.props.onDurationChanged) {
            this.props.onDurationChanged(this.videoPlayer().duration)
        }
    }

    onTimeUpdate() {
        let videoPlayer = this.videoPlayer()
        if (!videoPlayer) {
            return
        }
        let progress = videoPlayer
            ? this.videoPlayer().currentTime / this.videoPlayer().duration
            : 0
        if (this.props.onProgress) {
            this.props.onProgress(progress)
        }
        if (this.props.onTimeUpdate) {
            this.props.onTimeUpdate(
                videoPlayer.currentTime,
                videoPlayer.duration
            )
        }
    }
    onEnded() {
        this.debug("onEnded")
        if (this.props.onEnded) {
            this.props.onEnded()
        }
    }

    // Set default values for props if there are none
    // https://reactjs.org/docs/react-component.html#defaultprops
    static defaultProps: Props = {
        sourceType: SourceType.URL,
        file: "",
        url:
            "https://player.vimeo.com/external/297888125.hd.mp4?s=e19181157c6977e7a3b02e8ed44c1bfb509960b5&profile_id=172&oauth2_token_id=57447761&download=1",
        shouldPlay: false,
        shadow: true,
        debug: false,
        shadowRadius: 30,
        shadowOffset: 13,
        shadowColor: "rgba(0,0,0,0.2)",
        loop: false,
        muted: false,
        effects: false,
        cornerRadius: 10,
        greyscale: 0,
        saturation: 100,
        hue: 0,
        brightness: 100,
        contrast: 100,
        onEnded: null,
        onError: null,
        onPlaying: null,
        onPause: null,
        onPlay: null,
        onStalled: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onDurationChanged: null,
        onProgress: null,
        onTimeUpdate: null,
    }

    static propertyControls: PropertyControls<Props> = {
        sourceType: {
            type: ControlType.SegmentedEnum,
            title: "Source",
            options: [SourceType.URL, SourceType.File],
        },
        url: {
            type: ControlType.String,
            title: " ",
            placeholder: "http://website.com/example.mp4",
            hidden(props) {
                return props.sourceType === SourceType.File
            },
        },
        file: {
            type: ControlType.File,
            title: " ",
            allowedFileTypes: ["mp4", "mov"],
            hidden(props) {
                return props.sourceType === SourceType.URL
            },
        },
        loop: { type: ControlType.Boolean, title: "Loop" },
        muted: { type: ControlType.Boolean, title: "Muted" },
        shouldPlay: { type: ControlType.Boolean, title: "Play" },
        effects: { type: ControlType.Boolean, title: "Effects" },
        saturation: {
            type: ControlType.Number,
            title: "• Saturation",
            min: 0,
            max: 200,
            step: 1,
            hidden: props => {
                return props.effects != true
            },
        },
        hue: {
            type: ControlType.Number,
            title: "• Hue",
            min: 0,
            max: 360,
            step: 1,
            hidden: props => {
                return props.effects != true
            },
        },
        brightness: {
            type: ControlType.Number,
            title: "• Brightness",
            min: 0,
            max: 200,
            step: 1,
            hidden: props => {
                return props.effects != true
            },
        },
        contrast: {
            type: ControlType.Number,
            title: "• Contrast",
            min: 0,
            max: 200,
            step: 1,
            hidden: props => {
                return props.effects != true
            },
        },
        shadow: { type: ControlType.Boolean, title: "Shadow" },
        shadowRadius: {
            type: ControlType.Number,
            title: "• Blur",
            hidden: props => {
                return props.shadow == false
            },
        },
        shadowOffset: {
            type: ControlType.Number,
            title: "• Offset",
            hidden: props => {
                return props.shadow == false
            },
        },
        shadowColor: {
            type: ControlType.Color,
            title: "• Color",
            hidden: props => {
                return props.shadow == false
            },
        },
        cornerRadius: { type: ControlType.Number, title: "Corners" },
    }
}
